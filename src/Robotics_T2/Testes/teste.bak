#define VOL 3
//Lines TresHold
#define THRESHOLD_BLACK 30
#define THRESHOLD_WHITE 60
#define THRESHOLD_GREY 40
//Map
int map[][];
#define mapRes_length 10
#define mapRes_wiidth 10

#define NEAR 14
//Wait times****************
#define MOVE_TIME 500
#define TURN_TIME 300
#define WAIT_TIME 200
//Speed*********************
#define SLOW_VEL 25
#define MAX_AD_VEL 50

int Treshold_Line = 0;
int Treshold_Line1 = 0;
int Treshold_Victim = 0;
int Treshold_Victim1 = 0;

#define sensorRange 8

//TODO: ID Number Victims and Type
//TODO: Route time
//TODO: Victims Sound

struct flags
{
  bool _stopFlag;
};

struct distanceSensor{
  int d1; //Esquerda
  int d2; //Direita
  int d3; //Frente
  int d4; //Tras
};

struct lightSensor{
  int sensor_in3;
  int sensor_in4;
  int last_activated;
};

struct timerTable{
  long lineTime;
  long blackTime;
};

mutex distanceMutex;


bool lookingLeft=true;
flags myflags;
distanceSensor mydist;
lightSensor mylight;
timerTable mytimer;

sub init(){
  SetSensorLight(IN_3);
  SetSensorLight(IN_4);
  SetSensorLowspeed(IN_2);

}

sub calibration(){
  int calibrationDone = 0;

  while (calibrationDone < 2){

    mydist.d3 = SensorUS(IN_2);
    mylight.sensor_in3 = Sensor(IN_3);
    mylight.sensor_in4 = Sensor(IN_4);

    if (calibrationDone == 0) {
      TextOut(1, LCD_LINE1, "Calibrate Lines", true);
      if (mydist.d3 < NEAR){
        PlayToneEx(300, 400, 5, FALSE);
        Treshold_Line = mylight.sensor_in3;
        Treshold_Line1 = mylight.sensor_in4;

        //apagar ou comentar***********
        Treshold_Line=THRESHOLD_BLACK;
        Treshold_Line1=THRESHOLD_BLACK;
        //******************************

        TextOut(5, LCD_LINE2, "Done", true);
        NumOut(60, LCD_LINE3, Treshold_Line);
        NumOut(60, LCD_LINE4, Treshold_Line1);
        Wait(2000);
        calibrationDone++;
      }
    }

    mydist.d3 = SensorUS(IN_2);

    if (calibrationDone == 1) {
      TextOut(1, LCD_LINE3, "Calibrate Victims", true);
      if (mydist.d3 < NEAR){
        PlayToneEx(300, 400, 5, FALSE);
        Treshold_Victim = mylight.sensor_in3;
        Treshold_Victim1 = mylight.sensor_in3;

        //Apagar ou comentar************
        Treshold_Victim1=THRESHOLD_GREY;
        Treshold_Victim=THRESHOLD_GREY;
        //******************************

        TextOut(5, LCD_LINE2, "Done", true);
        NumOut(60, LCD_LINE3, Treshold_Victim);
        NumOut(60, LCD_LINE4, Treshold_Victim1);
        Wait(100);
        calibrationDone++;
      }
    }

  }



  do{
    mydist.d3 = SensorUS(IN_2);
  } while (mydist.d3 >= NEAR)

    PlayToneEx(262, 400, 3, FALSE);
  Wait(500);
  PlayToneEx(250, 400, 3, FALSE);
}

sub mazeSolver(){
  int maxDist = 25;
  int minDist = 23;
  int compensan=0;
  int isMaze=1;
  int orientation = 1;
  int d1;
  int d2;
  int d3;
  int oldD1, oldD2, oldD3;
  Acquire(distanceMutex);
    oldD1 = mydist.d1;
    oldD2 = mydist.d2;
    oldD3 = mydist.d3;
  Release(distanceMutex);
  OnFwdSync(OUT_AC, 20, compensan);
  while(isMaze){
    oldD1=d1;
    oldD2=d2;
    oldD3=d3;
    Acquire(distanceMutex);
    d1 = mydist.d1;
    d2 = mydist.d2;
    d3 = mydist.d3;
    Release(distanceMutex);
    ClearScreen();
    TextOut(15, LCD_LINE2, "Solving maze...");
    NumOut(40, LCD_LINE3, compensan);


    if(d1<NEAR && oldD1!=d1){
      if(compensan <5){
      compensan= compensan +1;
      }
      
      RotateMotorEx(OUT_AC, 20, 90, compensan, true, false);
      OnFwdSync(OUT_AC, 20, compensan);
    }
    else if(d1>maxDist && oldD1!=d1){
      if(compensan > -5){
      compensan = compensan - 1;
      }
      RotateMotorEx(OUT_AC, 20, 90, compensan, true, false);
      OnFwdSync(OUT_AC, 20, compensan);
    }
    if(d3<NEAR){
      Off(OUT_AC);
      RotateMotorEx(OUT_AC, 20, -90, 0, true, true);
      RotateMotorEx(OUT_AC, 20, -125,100, true, true);
      orientation++;
    }
  }
}

task getDistances(){
  while(true){
    Acquire(distanceMutex);
    if(lookingLeft){
      mydist.d3 = SensorUS(IN_2);
      Release(distanceMutex);

      //turn sensor Left.
      RotateMotor(OUT_B, 60, -90);
      Acquire(distanceMutex);
      mydist.d1 = SensorUS(IN_2);
      Release(distanceMutex);
      //turn sensor Right
      RotateMotor(OUT_B, 60, 90);
    }else{
      mydist.d3 = SensorUS(IN_2);
      Release(distanceMutex);
      //turn sensor Left.
      RotateMotor(OUT_B, 60, 90);
      Acquire(distanceMutex);
      mydist.d2 = SensorUS(IN_2);
      Release(distanceMutex);
      //turn sensor Right
      RotateMotor(OUT_B, 60, -90); 
    }
    Release(distanceMutex);
    Wait(50);
  }
}

task main()
{
int matrix[][][];
int matrix1[][];
int array[];
ArrayInit(array, 0, 4);
ArrayInit(matrix1, array, 6);
ArrayInit(matrix, matrix1, 6);
matrix[1][1][1]=2;
NumOut(15, LCD_LINE2, matrix[1][0][1]);
PlayToneEx(330,400,VOL,FALSE); Wait(250);

PlayToneEx(262,1600,VOL,FALSE); Wait(250);
PlayFileEx("vitimav2.rso",3,FALSE);
Wait(3000);
init();
calibration();
start getDistances;
mazeSolver();
}
